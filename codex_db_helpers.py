"""Helper utilities for extracting examples from internal databases.

This module exposes lightweight wrappers around the Menace SQLite databases
to make it easy to collect textual examples for training or analysis.  Four
fetcher functions are provided, each targeting a specific database and
returning :class:`Example` objects:

``fetch_enhancements``
    Summaries generated by :mod:`chatgpt_enhancement_bot`.

``fetch_workflow_summaries``
    Short descriptions from :mod:`workflow_summary_db`.

``fetch_discrepancies``
    Logged discrepancy messages from :mod:`discrepancy_db`.

``fetch_workflow_history``
    Evolution cycle actions from :mod:`evolution_history_db`.

Each fetcher accepts ``order_by`` (``"confidence"``, ``"outcome_score"`` or
``"timestamp"``), ``limit`` and ``include_embeddings`` parameters.  When
``include_embeddings`` is ``True`` the database's ``vector`` method is called
if available.  Queries always run with ``scope="all"`` via
``scope_utils.build_scope_clause`` so that records from every menace instance
are considered.

Default sort-field mappings used internally:

    +----------------------+---------------------------------------------+
    | Function             | Mapping                                      |
    +======================+=============================================+
    | ``fetch_enhancements``      | ``{"confidence": "confidence",``              |
    |                      | `` "outcome_score": "outcome_score",``             |
    |                      | `` "timestamp": "timestamp"}``                     |
    +----------------------+---------------------------------------------+
    | ``fetch_workflow_summaries``| ``{"timestamp": "workflow_id"}`` (other      |
    |                      | fields unsupported)                         |
    +----------------------+---------------------------------------------+
    | ``fetch_discrepancies``     | ``{"confidence": "confidence",``              |
    |                      | `` "outcome_score": "outcome_score",``             |
    |                      | `` "timestamp": "ts"}``                             |
    +----------------------+---------------------------------------------+
    | ``fetch_workflow_history``  | ``{"outcome_score": "COALESCE(roi,``         |
    |                      | ``performance)",``                                  |
    |                      | `` "timestamp": "ts"}`` (``confidence``             |
    |                      | unsupported)                                      |
    +----------------------+---------------------------------------------+

Example usage::

    >>> from codex_db_helpers import fetch_enhancements, aggregate_examples
    >>> ideas = fetch_enhancements(limit=5, order_by="confidence")
    >>> merged = aggregate_examples(order_by="timestamp", limit=20)

``aggregate_examples`` merges results from the individual fetchers, sorts the
combined list according to ``order_by`` and enforces the provided global
``limit``.
"""

from __future__ import annotations

from dataclasses import dataclass
import json
from typing import Any, Callable, Dict, Iterable, List, Optional

from chatgpt_enhancement_bot import EnhancementDB
from workflow_summary_db import WorkflowSummaryDB
from discrepancy_db import DiscrepancyDB
from evolution_history_db import EvolutionHistoryDB
from scope_utils import Scope, build_scope_clause


@dataclass
class Example:
    """Container representing a single training example."""

    text: str
    source: str
    confidence: Optional[float] = None
    outcome_score: Optional[float] = None
    timestamp: Optional[str] = None
    embedding: Optional[List[float]] = None
    metadata: Optional[Dict[str, Any]] = None


def _exec(conn, sql: str, params: Iterable[Any]) -> List[Any]:
    """Execute ``sql`` with ``params`` and return fetched rows."""

    cur = conn.execute(sql, list(params))
    return cur.fetchall()


def fetch_enhancements(
    *, order_by: str = "timestamp", limit: int = 100, include_embeddings: bool = False
) -> List[Example]:
    """Return enhancement summaries from :class:`EnhancementDB`."""

    db = EnhancementDB()
    columns = {
        "confidence": "confidence",
        "outcome_score": "outcome_score",
        "timestamp": "timestamp",
    }
    order_col = columns.get(order_by)
    if not order_col:
        raise ValueError(f"unsupported order field: {order_by}")

    menace_id = getattr(getattr(db, "router", None), "menace_id", "")
    clause, params = build_scope_clause("enhancements", Scope.ALL, menace_id)
    sql = (
        "SELECT id, summary, confidence, outcome_score, timestamp "
        "FROM enhancements"
    )
    if clause:
        sql += f" WHERE {clause}"
    sql += f" ORDER BY {order_col} DESC LIMIT ?"
    params.append(limit)

    rows = _exec(db.conn, sql, params)
    examples: List[Example] = []
    for row in rows:
        embedding = None
        if include_embeddings and hasattr(db, "vector"):
            try:
                embedding = db.vector(row["id"])
            except Exception:  # pragma: no cover - backend dependent
                embedding = None
        examples.append(
            Example(
                text=row["summary"],
                source="enhancement",
                confidence=row["confidence"],
                outcome_score=row["outcome_score"],
                timestamp=row["timestamp"],
                embedding=embedding,
                metadata={"id": row["id"]},
            )
        )
    return examples


def fetch_workflow_summaries(
    *, order_by: str = "timestamp", limit: int = 100, include_embeddings: bool = False
) -> List[Example]:
    """Return workflow summaries from :class:`WorkflowSummaryDB`."""

    if order_by != "timestamp":
        raise ValueError("workflow summaries only support timestamp ordering")

    db = WorkflowSummaryDB()
    menace_id = getattr(getattr(db, "router", None), "menace_id", "")
    clause, params = build_scope_clause("workflow_summaries", Scope.ALL, menace_id)
    sql = "SELECT workflow_id, summary FROM workflow_summaries"
    if clause:
        sql += f" WHERE {clause}"
    sql += " ORDER BY workflow_id DESC LIMIT ?"
    params.append(limit)

    rows = _exec(db.conn, sql, params)
    examples: List[Example] = []
    for row in rows:
        embedding = None
        if include_embeddings and hasattr(db, "vector"):
            try:
                embedding = db.vector(row["workflow_id"])
            except Exception:  # pragma: no cover - backend dependent
                embedding = None
        examples.append(
            Example(
                text=row["summary"],
                source="workflow_summary",
                timestamp=None,
                embedding=embedding,
                metadata={"workflow_id": row["workflow_id"]},
            )
        )
    return examples


def fetch_discrepancies(
    *, order_by: str = "timestamp", limit: int = 100, include_embeddings: bool = False
) -> List[Example]:
    """Return discrepancy messages from :class:`DiscrepancyDB`."""

    db = DiscrepancyDB()
    columns = {
        "confidence": "confidence",
        "outcome_score": "outcome_score",
        "timestamp": "ts",
    }
    order_col = columns.get(order_by)
    if not order_col:
        raise ValueError(f"unsupported order field: {order_by}")

    menace_id = getattr(getattr(db, "router", None), "menace_id", "")
    clause, params = build_scope_clause("discrepancies", Scope.ALL, menace_id)
    sql = (
        "SELECT id, message, metadata, confidence, outcome_score, ts "
        "FROM discrepancies"
    )
    if clause:
        sql += f" WHERE {clause}"
    sql += f" ORDER BY {order_col} DESC LIMIT ?"
    params.append(limit)

    rows = _exec(db.conn, sql, params)
    examples: List[Example] = []
    for row in rows:
        try:
            meta = json.loads(row["metadata"]) if row["metadata"] else {}
        except Exception:  # pragma: no cover - defensive
            meta = {}
        embedding = None
        if include_embeddings and hasattr(db, "vector"):
            try:
                embedding = db.vector(row["id"])
            except Exception:  # pragma: no cover - backend dependent
                embedding = None
        meta_with_id: Dict[str, Any] = {"id": row["id"], **meta}
        examples.append(
            Example(
                text=row["message"],
                source="discrepancy",
                confidence=row["confidence"],
                outcome_score=row["outcome_score"],
                timestamp=row["ts"],
                embedding=embedding,
                metadata=meta_with_id,
            )
        )
    return examples


def fetch_workflow_history(
    *, order_by: str = "timestamp", limit: int = 100, include_embeddings: bool = False
) -> List[Example]:
    """Return evolution history entries from :class:`EvolutionHistoryDB`."""

    db = EvolutionHistoryDB()
    if order_by == "timestamp":
        order_expr = "ts"
    elif order_by == "outcome_score":
        order_expr = "COALESCE(roi, performance)"
    else:
        raise ValueError("workflow history does not support confidence ordering")

    menace_id = getattr(getattr(db, "router", None), "menace_id", "")
    clause, params = build_scope_clause("evolution_history", Scope.ALL, menace_id)
    sql = (
        "SELECT rowid as id, action, roi, performance, ts "
        "FROM evolution_history"
    )
    if clause:
        sql += f" WHERE {clause}"
    sql += f" ORDER BY {order_expr} DESC LIMIT ?"
    params.append(limit)

    rows = _exec(db.conn, sql, params)
    examples: List[Example] = []
    for row in rows:
        outcome = row["roi"] if row["roi"] is not None else row["performance"]
        embedding = None
        if include_embeddings and hasattr(db, "vector"):
            try:
                embedding = db.vector(row["id"])
            except Exception:  # pragma: no cover - backend dependent
                embedding = None
        examples.append(
            Example(
                text=row["action"],
                source="workflow_history",
                outcome_score=outcome,
                timestamp=row["ts"],
                embedding=embedding,
                metadata={"id": row["id"]},
            )
        )
    return examples


_FETCHERS: Dict[str, Callable[..., List[Example]]] = {
    "enhancements": fetch_enhancements,
    "workflow_summaries": fetch_workflow_summaries,
    "discrepancies": fetch_discrepancies,
    "workflow_history": fetch_workflow_history,
}


def aggregate_examples(
    *,
    order_by: str = "timestamp",
    limit: int = 100,
    include_embeddings: bool = False,
    sources: Optional[Iterable[str]] = None,
) -> List[Example]:
    """Merge examples from multiple sources and apply global sorting/limiting."""

    if sources is None:
        sources = _FETCHERS.keys()

    examples: List[Example] = []
    for name in sources:
        fetcher = _FETCHERS.get(name)
        if not fetcher:
            raise ValueError(f"unknown source: {name}")
        examples.extend(
            fetcher(order_by=order_by, limit=limit, include_embeddings=include_embeddings)
        )

    key_map: Dict[str, Callable[[Example], Any]] = {
        "confidence": lambda ex: ex.confidence or 0.0,
        "outcome_score": lambda ex: ex.outcome_score or 0.0,
        "timestamp": lambda ex: ex.timestamp or "",
    }
    key = key_map.get(order_by)
    if key is None:
        raise ValueError(f"unsupported order field: {order_by}")

    examples.sort(key=key, reverse=True)
    return examples[:limit]


__all__ = [
    "Example",
    "fetch_enhancements",
    "fetch_workflow_summaries",
    "fetch_discrepancies",
    "fetch_workflow_history",
    "aggregate_examples",
]

