"""Helpers for resilient cooperative ``__init__`` invocations.

The sandbox wires together a wide range of bot classes that historically
expected only positional arguments.  As more services were introduced, keyword
arguments such as ``event_bus`` or ``manager`` started being threaded through
the constructor chain.  When a class still ultimately inherits from
``object`` without consuming those keywords, ``TypeError`` is raised with the
familiar ``object.__init__() takes exactly one argument`` message.

This module centralises the logic for retrying constructor calls without the
autogenerated cooperative keywords and for falling back to ``object.__init__``
when appropriate.  It also exposes a small utility for marking classes as
"cooperative safe" so that loaders can ensure third party classes participate
in the resilient initialisation path without hand-written wrappers at every
call site.
"""

from __future__ import annotations

from collections.abc import Iterable, Mapping
from functools import wraps
import logging
from typing import Any, Callable, TypeVar

Logger = logging.Logger
KwargTrace = Callable[[object, type, tuple[str, ...], Mapping[str, Any]], None]
T = TypeVar("T", bound=type)

logger = logging.getLogger(__name__)

# Cooperative initialisation commonly injects these keyword arguments.  The
# default list intentionally errs on the side of inclusion so the retry logic
# can de-noise failures originating from ``object.__init__``.
COOPERATIVE_INIT_KWARGS: tuple[str, ...] = (
    "bot_registry",
    "data_bot",
    "manager",
    "evolution_orchestrator",
    "event_bus",
    "data_store",
    "workflow_id",
)


def type_error_is_unexpected_kwarg(
    exc: TypeError, *, keywords: Iterable[str]
) -> bool:
    """Return ``True`` when *exc* indicates unsupported keyword arguments."""

    message = exc.args[0] if exc.args else ""
    if "unexpected keyword argument" not in message and "takes no keyword" not in message:
        return False
    return any(keyword in message for keyword in keywords)


def type_error_from_object_init(exc: TypeError) -> bool:
    """Return ``True`` when *exc* originated from ``object.__init__``."""

    message = exc.args[0] if exc.args else ""
    if "object.__init__" not in message:
        return False
    return "argument" in message or "arguments" in message or "parameters" in message


def _filter_injected_kwargs(
    kwargs: Mapping[str, Any], injected_keywords: Iterable[str]
) -> tuple[dict[str, Any], tuple[str, ...]]:
    injected_set = set(injected_keywords)
    filtered = {key: value for key, value in kwargs.items() if key not in injected_set}
    dropped = tuple(key for key in kwargs.keys() if key not in filtered)
    return filtered, dropped


def cooperative_init_call(
    init: Callable[..., None],
    instance: object,
    *args: Any,
    injected_keywords: Iterable[str] = COOPERATIVE_INIT_KWARGS,
    logger: Logger | None = None,
    cls: type | None = None,
    kwarg_trace: KwargTrace | None = None,
    **kwargs: Any,
) -> dict[str, Any]:
    """Invoke ``init`` with cooperative retry semantics.

    The function mirrors the behaviour implemented by
    :func:`menace_sandbox.coding_bot_interface.self_coding_managed` where
    keyword arguments injected for cooperative helper bootstrapping are retried
    without those parameters before ultimately falling back to
    ``object.__init__``.  A dictionary describing the recovery path is returned
    so callers can emit additional diagnostics when desired.
    """

    target_cls = cls or type(instance)
    log = logger or logging.getLogger(getattr(target_cls, "__module__", __name__))
    state: dict[str, Any] = {
        "dropped": tuple[str, ...](),
        "object_fallback": False,
        "retried": False,
    }

    try:
        init(instance, *args, **kwargs)
    except TypeError as exc:
        filtered_kwargs, dropped = _filter_injected_kwargs(kwargs, injected_keywords)
        if dropped and type_error_is_unexpected_kwarg(exc, keywords=dropped):
            state["dropped"] = tuple(sorted(dropped))
            state["retried"] = True
            if kwarg_trace is not None:
                try:
                    kwarg_trace(instance, target_cls, state["dropped"], kwargs)
                except Exception:  # pragma: no cover - best effort tracing
                    log.debug(
                        "%s: kwarg trace callback failed",
                        target_cls.__name__,
                        exc_info=True,
                    )
            if log is not None:
                log.debug(
                    "%s: dropping cooperative init kwargs %s before invoking %s.__init__",
                    target_cls.__name__,
                    ", ".join(state["dropped"]),
                    getattr(init, "__qualname__", init.__name__),
                )
            try:
                init(instance, *args, **filtered_kwargs)
            except TypeError as exc_inner:
                if type_error_from_object_init(exc_inner):
                    state["object_fallback"] = True
                    if log is not None:
                        log.debug(
                            "%s: falling back to object.__init__ after cooperative init drop; args=%s kwargs=%s",
                            target_cls.__name__,
                            args,
                            filtered_kwargs,
                        )
                    object.__init__(instance)
                else:
                    raise
        elif type_error_from_object_init(exc):
            state["object_fallback"] = True
            if kwarg_trace is not None:
                try:
                    kwarg_trace(instance, target_cls, tuple(sorted(kwargs.keys())), kwargs)
                except Exception:  # pragma: no cover - best effort tracing
                    log.debug(
                        "%s: kwarg trace callback failed",
                        target_cls.__name__,
                        exc_info=True,
                    )
            if log is not None:
                log.debug(
                    "%s: falling back to object.__init__ during cooperative init; args=%s kwargs=%s",
                    target_cls.__name__,
                    args,
                    kwargs,
                )
            object.__init__(instance)
        else:
            raise

    return state


def ensure_cooperative_init(
    cls: T,
    *,
    injected_keywords: Iterable[str] = COOPERATIVE_INIT_KWARGS,
    logger: Logger | None = None,
    kwarg_trace: KwargTrace | None = None,
) -> T:
    """Ensure ``cls.__init__`` participates in cooperative retry semantics."""

    init = getattr(cls, "__init__", None)
    if not callable(init):
        return cls
    if getattr(init, "__cooperative_safe__", False):  # type: ignore[attr-defined]
        return cls

    log = logger or logging.getLogger(getattr(cls, "__module__", __name__))

    @wraps(init)
    def wrapper(self: object, *args: Any, **kwargs: Any) -> None:
        cooperative_init_call(
            init,
            self,
            *args,
            injected_keywords=injected_keywords,
            logger=log,
            cls=cls,
            kwarg_trace=kwarg_trace,
            **kwargs,
        )

    wrapper.__cooperative_safe__ = True  # type: ignore[attr-defined]
    cls.__init__ = wrapper  # type: ignore[assignment]
    return cls


__all__ = [
    "COOPERATIVE_INIT_KWARGS",
    "cooperative_init_call",
    "ensure_cooperative_init",
    "type_error_from_object_init",
    "type_error_is_unexpected_kwarg",
]

