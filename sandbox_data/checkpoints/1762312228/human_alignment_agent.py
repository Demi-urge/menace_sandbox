from __future__ import annotations

"""Lightweight agent for evaluating self-improvement changes.

The :class:`HumanAlignmentAgent` wraps :func:`flag_improvement` to provide a
simple interface for checking proposed workflow changes.  Any warnings produced
by the flagger are written to the violation log using
:func:`violation_logger.log_violation`.
"""

from typing import Any, Dict, List

from sandbox_settings import SandboxSettings
from human_alignment_flagger import flag_improvement
try:
    from .violation_logger import log_violation  # type: ignore
except Exception:  # pragma: no cover - fallback for flat layout
    from violation_logger import log_violation  # type: ignore


class HumanAlignmentAgent:
    """Evaluate workflow modifications for alignment concerns."""

    def __init__(self, settings: SandboxSettings | None = None) -> None:
        self.settings = settings or SandboxSettings()

    def evaluate_changes(
        self,
        workflow_changes: List[Dict[str, Any]] | None,
        metrics: Dict[str, Any] | None,
        logs: List[Dict[str, Any]] | None,
        commit_info: Dict[str, Any] | None = None,
    ) -> Dict[str, List[Dict[str, Any]]]:
        """Return warnings for the proposed *workflow_changes*.

        Warnings are generated by :func:`flag_improvement` and any entries with a
        normalised severity above the configured thresholds are persisted via the
        violation logger.  When ``commit_info`` is provided its message is also
        scanned for ethical violations.
        """

        warnings = flag_improvement(
            workflow_changes, metrics, logs, commit_info, settings=self.settings
        )
        warn_th = getattr(self.settings, "improvement_warning_threshold", 0.0)
        fail_th = getattr(self.settings, "improvement_failure_threshold", 1.0)

        for category, entries in warnings.items():
            for idx, warn in enumerate(entries):
                severity = int(warn.get("severity", 1))
                norm = severity / 4.0
                if norm < warn_th:
                    continue
                violation_type = "alignment_warning"
                if norm >= fail_th:
                    violation_type = "alignment_failure"
                evidence: Dict[str, Any] = {
                    "category": category,
                    "file": warn.get("file"),
                    "issue": warn.get("issue") or warn.get("message"),
                }
                if "snippet" in warn:
                    evidence["snippet"] = warn["snippet"]
                if "snippets" in warn:
                    evidence["snippets"] = warn["snippets"]
                log_violation(
                    f"improvement_{category}_{idx}",
                    violation_type,
                    severity,
                    evidence,
                    alignment_warning=True,
                )

        return warnings
